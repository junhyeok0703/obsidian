
다이나믹 프로그래밍이라는 뜻이고 동적계획법이라고도 부른다.
한줄로 이야기하면 한번 계산한 문제는 다시 풀지않도록 하는 알고리즘이다.
예를 들어 피보나치 수열 문제에서 재귀호출로 풀게되는 경우이다.
### 피보나치 수열이란?
- 이전 두열의 합을 현재의 항으로 설정하는 특징을 가지고 있는 수열이다.
- 0 -> 1 -> 1 -> 2 -> 3 -> 5 이런식으로 진행이 된다.
### 재귀로 피보나치를 구현해보자
```python
fibo(x):
	if x==1 or x==2:
		return 1
	return fibo(x-1) + fibo(x-2)
```
### 재귀로 풀었을 경우 중복이 생김
- 전 값과 전전값이 현재항을 나타낸다고 하였다. 이때 4번째 항을 구하기 위해서
- 첫번째항과 두번째항을 더하여 3번째 항을 만들고 2번째항과 3번째항을 더해서 4번째 항을 구하게 된다.
- 이러면 두번째항이 두번반복해 구하게 된다. 즉 재귀함수는 그때 2번째항을 두번을 불러서 2번째항을  구해서
- 가져오기때문에 이런식으로 중복되는게 생긴다. 숫자가 커질수록은 중복은 더욱더 많아진다.
	-> 이런식으로 하면 시간복잡도 O(n^2) 가 된다.
### DP는 이렇게 풀수있어
- 이러한 중복을 구하지않고 저장하고있다가 2번째항 이미 구했어 그러면 4번째항  구할때 2번째항은 이거써
- 이런식으로 중복을 처리하는것이 DP라고 할수있다.
	-> 이런식으로 하면 시간복잡도가 O(N)이 된다.
### DP의 조건
1. 큰 문제를 작은 문제로 나눌수있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다 
### 메모이제이션 기법 - 캐싱
- 메모이제이션은 DP를 구현 하는 방법 중 한종류다. 한번 구한 결과를 메모리 공간에 메모해두고(저장) 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법
### 메모이제이션,재귀,탑다운로 피보나치를 구현해보자
```python
d = [0]*100
def fibo(x):
	if x == 1 or x == 2:
		return 1
	if d[x] !=0:
		return d[x]
	d[x] = fibo(x-1)+fibo(x-2)
	return d[x]
print(fibo(99))	
```
### 그러면 퀵정렬은 DP야?
퀵정렬은 저번시간에 이야기했다. 피봇을 정하여서 피봇중심으로 왼쪽은 피봇보다 작은수 , 오른쪽은 피봇보다 큰수로 나눴다. 또 나눈 두 리스트에서 피봇을 정하고 거기서 피봇을 알맞은곳에 넣어서 또 왼쪽은 작은거 오른쪽은 큰거 이런식으로 작은 문제로 나눠서 정렬하는 방법이다.
이는 분할 정복 알고리즘으로 분류된다.

분할정복과 DP프로그래밍의 차이점은 DP의 문제들은 서로 영향을 미치고 있다는 점이다.
퀵정렬은 피봇값으로 나눌때 그 피봇은 그자리에서 이제 더이상 움직이지 않고 그 피봇값을 다시 처리하지않는다.
반면 DP는 한 번 해결했던 문제를 다시금 해결한다는 점이 특징이다. 그렇기 때문에 이미 해결된 부분 문제에 대한 답을 저장해놓고 이 문제는 이미 해결 됬으니까 다시 해결할 필요가 없다고 반환하는 것이다.
예를 들어 메모이제이션,재귀로 푼 피보나치를 보게 되면 한번 푼 문제는 결과를 저장해놨다가 동일할 문제를 풀어야할때 이미 저장한 값을 반환하게 된다. (계산하지않고 반환만 하는거는 노드를 방문을 안했다고 해도 무방함,단  이런현상은 오버헤드도 발생할수있다.) -> 그래서 반복문을 사용하면 오버헤드를 줄일수있다.
그래서 O(N)이 된다.


### DP,반복문으로 구현하는 피보나치 수열 - 바텀업
```python
d = [0] * 100
d[1]=1
d[2]=1
n = 99

for i in range(3,n+1):
	d[i] = d[i-1]+d[i-2]
print(d[n])
```
### 바텀업,탑다운
하향식,상향식이라고도 부르는데 재귀함수는 n부터 내려오니까 탑다운, for문은 밑단부터시작하니까 바텀업?이다.
바텀업은 저장용 리스트는 DP테이블, 메모이제이션은 탑다운 방식에 국한되어있는 표현.